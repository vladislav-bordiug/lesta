# Вопрос №1 [Решение](https://github.com/vladislav-bordiug/lesta/blob/main/1.py "Решение")

Обе функции делают тоже самое, но первая функция использует остаток от деления, что обычно всегда применяют для определения четности числа. Вторая функция делает тоже самое, то есть мы также смотрим на остаток от деления, т.к. ```число // делитель * делитель - число = остаток от деления```, но вычисляем его через операции целочисленного деления и умножения.

- Первая функция использует одну операцию, что плюс
- Вторая функция использует две операции, что минус
- Первая функция требует знать хотя бы что такое остаток от деления, что может быть минусом
- Вторая функция использует самые очевидные операции (умножение и деление), что плюс

# Вопрос №2 [Решение](https://github.com/vladislav-bordiug/lesta/blob/main/2.py "Решение")

Первый класс реализует FIFO очередь, используя **deque** из **collections**, а второй класс использует двустороннюю очередь.

В целом оба класса по сути своей похожи, т.к. **deque** как раз и реализована как двусторонная очередь.

Оба класса реализуют очередь максимальное эффективно, т.е. методы **add**, **remove** и **CheckFirst** **O(1)** по времени.

**add** - добавление элемента в конец очереди.

**remove** - удаляет первый элемент из очереди.

**CheckFirst** - возвращает первый элемент из очереди.

# Вопрос №3 [Решение](https://github.com/vladislav-bordiug/lesta/blob/main/3.py "Решение")

Сортировка реализована с помощью рекурсии и алгоритма сортировки слиянием, т.к. это самый эффективный алгоритм, стандартные методы сортировки в Питоне и используют его.

**O(nlogn)** - сложность по времени (худшее, лучшее и среднее время).

**O(n)** - сложность по памяти.

Также существует алгоритм быстрой сортировки, но он в худшем случае **O(n^2)** по памяти. 

Есть еще алгоритм counting sort, который создает словарь из элементов и их количеств, а потом проходится в цикле от минимального элемента и максимального, и в соответствии с количеством каждого элемента перезаписывает элементы в массиве, каждый раз увеличивая индекс для последующей записи на 1. Этот алгоритм имеет сложность **O(n+m)**, где n - количество элементов в массиве, а m - разность между максимальным и минимальным элементом. Если m <= n, то алгоритм все-таки будет работать линейно. Но в итоге при больших значениях элементов массива он будет работать хуже, т.к. m будет очень большим.

Поэтому получается, что из всех алгоритмов оптимальнее всего сортировка слиянием.
